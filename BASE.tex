\documentclass[12pt, twocolumn, a4paper]{article}
\usepackage{multicol, lipsum}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pslatex}
\usepackage[dvipsnames]{xcolor}
\usepackage[a4paper, left=2cm, right=2cm, top=3cm, bottom=2cm,
		headsep=1cm, footskip=2cm]{geometry}
\usepackage[brazil]{babel}

\begin{document}
	\title{SystemVerilog Vocabulary Extractor}
	\author{Filipe C. Cavalcanti\\ Leandro de S. Albuquerque\\
	Orientador: Tio Kat}
	\maketitle
	
	\section{ABSTRACT}
	
	\section{RESUMO}
	\quad Desde a criação da primeira HDL até os presentes dias, cada vez mais o desenvolvimento de sistemas digitais se assemelha e aproxima-se a codificações de programas descritos em linguagem de programação  
	
% Keywords: HDL, SystemVerilog, Software Vocabulary, Hardware Vocabulary, sistemas digitais  
	\section{Introdução}

\quad Verilog foi uma das primeiras linguagens para descrição de hardware (HDL) a ser inventada em meados da década de 80. Até então o tamanho típico dos projetos era entre 5 a 10 mil portas lógicas. 

O método de concepção dos circuitos utilizava-se de esquema gráfico, e a simulação começava a ser  ferramenta essencial para verificação\cite{sutherland2006}. Com a evolução da tecnologia de descrição e verificação de hardware, em 2002 surge SystemVerilog. 

A partir disto, como a complexidade de sistemas digitais modernos aumentou exponencialmente, tanto que, o tamanho dos atuais projetos chega a ordem dos bilhões de portas lógicas. Assim as metodologias de projetos em sistemas digitais estão evoluindo extensivamente \cite{Marc-Andre} e \cite{Hahanov2008}.

Com tal avanço, elevou-se o nível de abstração no desenvolvimento de hardware por meio de uma linguagem de descrição e verificação de hardware (HDVL), de tal forma que, o uso de ferramentas de análise de informações que antes eram somente do escopo da engenharia de software, pode ser estendido também para o desenvolvimento de sistemas digitais.

Umas das principais fontes de informações em um código fonte no âmbito da engenharia de software, é o vocabulário. Dentre suas principais utilidades listamos o seguinte:

\quad 1. Localização de bugs;

\quad 2. Identificação de uma arquitetura;

\quad 3. Métricas sobre o código fonte;

\quad 4. Identificação de especialista \cite{Santos2015}.

O vocabulário de software também denominado de léxico do código em \cite{Biggers2011}, consiste no conjunto de termos repetidos ou únicos que compõem identificadores e que estão presentes no textos dos comentários\cite{Abebe2009}.

Usando os princípios da engenharia reversa como uma coleção de metodologias e técnicas capazes de realizar a extração e abstração de informações\cite{Santos2009}, propõe-se neste trabalho a extração do vocabulário pertencentes a projetos de hardware descritos em SystemVerilog, e usando a definição formal de Santos em \cite{Santos2015} sobre vocabulário de software para embasar e fundamentar o termo \textit{Hardware Vocabulary}. 

	\section{Background}
\quad Graças aos atuais projetos eletrônicos baseado em HDL, metodologias e ferramentas para simulação, síntese, verificação, modelagem física e teste pós-fabricação agora estão bem inseridos e são essenciais para designers digitais \cite{Navabi2015}. 

Nos últimos anos as linguagens de descrição e verificação de hardware tornaram-se tão importantes para a modelagem de sistemas digitais, quanto as linguagens de programação o são para a engenharia de software. 
	
	\subsection{Software Vocabulary}
\quad Santos em \cite{Santos2009}, define que vocabulário de código fonte compreende as cadeias de caracteres que identificam os elementos estruturais e as palavras que compõem as sentenças dos comentários de um código fonte. 

Dentro dos campos de estudo da engenharia de software outro termo bastante conhecido e isomorfo a \textit{Software Vocabulary} é o \textit{léxico do código} que em \cite{Biggers2011} são os elementos que nomeiam as entidades estruturais da linguagem além dos comentários escritos em linguagem natural.

 \textit{Software Vocabulary} é um multiconjunto de \textit{Strings}, i.e., uma aplicação $V:$ $\mathbb{S}\rightarrow\mathbb{N}$, que mapeia \textit{Strings} para números naturais. Elementos de um vocabulário são chamados \textit{termos}. Para qualquer termo $t$, $V(t)$ representa o número de ocorrências do termo $t$ no vocabulário $V$. Se $V(t)>0$ dizemos que $t$ é um termo do vocabulário \cite{Santos2015}.

% O lexico de um programa representa um investimento substancial para uma empresa de software, portanto, seu valor deve preservado e aumentado ao longo do tempo, para aproveitar ao máximo seus efeitos benéficos na compreensão do programa.(Antoniol)

No paradigma de programação dominante atualmente OOP(\textit{Object-Oriented Programming}), nomear os elementos estruturais da linguagem de forma concisa e representativa além de documentá-las, tem sido mais do que uma boa prática.

 No desenvolvimento de grandes sistemas de software o vocabulário ou léxico, quando condizente ao problema, reduz o tempo de manutenção, facilita o entendimento do código e encontro de \textit{bugs}.

O léxico de um programa representa um investimento substancial para uma empresa de software, portanto, sua importância deve preservada e elevada ao longo do tempo, para aproveitar ao máximo seus efeitos e benéficos na compreensão do programa \cite{Antoniol2007}.

	\subsection{O Que é Uma HDL?}
%\quad HDVL (Hardware Description and Verification Language), podemos abstrair como um único ambiente para design e verificação de sistemas digitais, em \cite{Flake} uma HDVL representa hardware digital em vários níveis de abstração.

\quad Uma descrição HDL(\textit{Hardware Description Language}) é uma representação precisa que pode ser usada para documentar, comunicar e simular o projeto \cite{Miller-Karlow}.

As HDLs modernas são fundamentais para o desenvolvimento de sistemas digitais, possibilitando suas descrições de forma estrutural, comportamental e nos últimos anos, seguindo conceitos básicos de orientação a objetos \cite{Hahanov2008}, fornecendo assim um mecanismo efetivo para o desenvolvimento de projetos à medida que evoluem da abstração para a realidade \cite{Navabi2015}.

Algumas HDls evoluíram de tal forma que, além de descrever hardware, passaram também a englobar todo um ambiente de verificação. Tais linguagens foram tipificadas de HDVL (Hardware Description and Verification Language).

Devido a grande quantidade de HDLs disponíveis, limitamos o escopo deste trabalho à análise de informações somente para projetos descritos em SystemVerilog.

A escolha dessa linguagem deve-se ao seu grande uso na industria VLSI (\textit{Very Large Scale Integration} \cite{Kumar2014} e também por SystemVerilog ser uma HDVL \cite{IEEEComputerSociety2013}, ampliando assim nosso horizonte de informações, uma vez que temos dados tanto sobre descrição quanto verificação de hardware.

%--------------apagar essa parada!!!! DATTEBAYO
%A sintaxe pesada de uma HDL apresenta um problema no desenvolvimento de projetos, pois descreve um sistema complexo e multifacetado por meio de uma representação textual unidimencional, dificultando a abstração de \textit{\textbf{muitos}} aspetos do projeto.

	\subsection{O Hardware Como Um Software}
\quad A evolução no processo de desenvolvimento de software atrela-se ao fato do constante avanço dos paradigmas de programação, desde a programação procedural até a orientação a objetos.

De forma análoga, a evolução do processo de desenvolvimento de hardware, atrela-se também ao constante avanço dos métodos em desenvolver sistemas digitais. Indo desde esquemas gráficos à descrição baseada em orientação a objetos e verificação UVM (\textit{Universal Verification Methodology}).

A aproximação (similaridade no processo de desenvolvimento) do software ao hardware surge da criação das HDLs. Neste ponto da evolução tecnológica, tanto hardware quanto software eram desenvolvidos por meio de uma representação textual unidemensional, seguindo uma determinada sintaxe e semântica.

Em \cite{Hahanov2008} classes e módulos são coisas bastantes semelhantes, trazendo assim a possibilidade de usar classes dentro de um contexto de verificação de hardware. A partir desta similaridade, o inverso também é possível, ou seja, utilizar de conceitos e convenções de orientação a objetos na descrição de módulos.

Por fim, levantada todas as semelhanças do processo de desenvolvimento de hardware ao software, concluímos que toda analise, extração, métricas e conclusões feitas em cima do vocabulário de software são equivalentes quando aplicadas ao Vocabulário de Hardware.

	\subsection{Hardware Vocabulary} 
	
\quad Baseado fortemente pela definição formal de vocabulário de software em  \cite{Santos2015}, e embasado também por todo o levantamento feito sobre as semelhanças entre os processos de desenvolvimento entre hardware e software feitas na sessão anterior. Chegamos a primeira definição sobre vocabulário de hardware:
	
(1) Dada uma linguagem de descrição e (ou) verificação de hardware, temos que as sequencias de caracteres que nomeiam as entidades estruturais, assim como os blocos de comentários são chamados de \textit{Vocabulário de Hardware}.

Complementando tal definição, o vocabulário de hardware refere-se também a como estes dados estão organizados, ou seja, a estruturação da informação refletindo as entidades a qual o léxico pertence, de modo que só com o vocabulário possa ser possível criar uma entidade complementar a original (entidade que seu vocabulário foi extraído).

Notando tal semelhança a definição de vocabulário de software e sabendo de seu isomorfismo com léxico do código(definição dada por Biggers em \cite{Biggers2011}), chegamos a conclusão que (1) também pode ser chamado de \textit{léxico do hardware}.

Uma exemplificação é dada a partir de um trecho de código mostrado na \textit{Listing 1}, onde seu vocabulário extraído, está numa representação VXL(Vocabulary XML).
\begin{center}
{\footnotesize Listing 1: Execerpt of code SystemVerilog}
\end{center}
{\footnotesize
\textcolor{gray}{/* the module nextAddress returns the}
\textcolor{gray}{next address of the 2-bit offset program}
\textcolor{gray}{*/}\\
\textcolor{blue}{module} nextAddress(\\\textcolor{blue}{\qquad input logic}[\textcolor{green}{7}:\textcolor{green}{0}] regCounter,\\ \textcolor{blue}{\qquad input logic}[\textcolor{green}{7}:\textcolor{green}{0}] regAddress\\
\textcolor{blue}{\qquad output logic}[\textcolor{green}{7}:\textcolor{green}{0}] regPC);\\
\textcolor{blue}{\quad always\_comb begin}\\
\textcolor{black}{\qquad regPC $<$= (regCounter + regAddress)} \textcolor{blue}{$<<$} \textcolor{green}{2};\\
\textcolor{blue}{\quad end}\\
\textcolor{blue}{endmodule}: nextAdrres\\
\begin{center}
{\footnotesize Listing 2: Extracted Vocabulary of Listing 1}
\end{center}}
{\footnotesize
\textcolor{blue}{$<$module} \textcolor{red}{\,name=} ``\textcolor{purple}{nextAddress}"\textcolor{blue}{$>$}\\
\textcolor{blue}{\quad$<$param$>$}\\
\textcolor{blue}{\qquad$<$field} \textcolor{red}{type=}``\textcolor{purple}{input logic[7:0]}"\textcolor{red}{\,name=}\\\textcolor{black}{\qquad ``}\textcolor{purple}{regCounter}" \textcolor{blue}{/$>$}\\
\textcolor{blue}{\qquad$<$field} \textcolor{red}{type=}``\textcolor{purple}{input logic[7:0]}"\textcolor{red}{\,name=}\\\textcolor{black}{\qquad ``}\textcolor{purple}{regAddress}" \textcolor{blue}{/$>$}\\
\textcolor{blue}{\qquad$<$field} \textcolor{red}{type=}``\textcolor{purple}{output logic[7:0]}"\textcolor{red}{\,name=} ``\textcolor{purple}{regPC}" \textcolor{blue}{/$>$}\\
\textcolor{blue}{\quad$<$/param$>$}\\
\textcolor{blue}{\quad$<$comment} \textcolor{red}{cmm=}``\textcolor{purple}{the module nextAddress returns the next address of the 2-bit offset program}"\textcolor{blue}{/$>$}\\
\textcolor{blue}{$<$/module$>$}}\\

Como pode ser notado no resultado da extração do vocabulário, a estruturação dos dados segue fielmente a modelagem original do problema, assim sendo a partir do vocabulário pode-se recriar uma entidade complementar a original.

Sendo $\mathbb{S}$ o conjunto de todo o código fonte descrito por HDL, seja $\alpha$ um elemento deste conjunto, temos que o vocabulário de hardware é definido como  a imagem da função $F(\alpha)$, onde $im(F) = \mathbb{V}$ é o agrupamento dos dados na forma real da modelagem destes dados. Assim $F: \mathbb{S}\rightarrow\mathbb{V}$

	\section{SystemVerilog Vocabulary Extractor}

\quad Com a necessidade de analisar e extrair o vocabulário de hardware pertencentes a projetos descritos em SystemVerlog, desenvolvemos o ferramental \textit{Hardware Vocabulary Tool}.

A implementação desta ferramenta, baseia-se em entidades que são capazes de processar o vocabulário de hardware dos principais elementos estruturais básicos de SystemVerilog. Usando de delegação montam-se as estruturas mais complexas da linguagem (classes, interfaces, módulos e pacotes) Ex.: Uma classe SystemVerilog é uma entidade que possui um nome e compõem-se principalmente de atributos, funções, tasks, comentários.
	
Afim de validarmos a ferramenta calculamos uma porcentagem de extracão que melhor represente a eficiência do software proposto, elaborando um design genérico com todas as estruturas possíveis da linguagem SistemVerilog. Os resultados obtidos são apresentados na tabela abaixo:

\begin{table}[h]
\centering
\caption{Porcentagem de extração das principais entidades de SystemVerilog.}
	\begin{tabular}{l|c}
	\hline
	Entidade  & Porcentagem de extração\\
	\hline
	module     & 90\% \\
	\hline
	class 	   & 95\% \\
	\hline
	interface  & 90\% \\
	\hline
	function   & 90\% \\
	\hline
	task       & 90\% \\
	\hline
	fields     & 100\% \\
	\hline
	
	\end{tabular}

\end{table}
Os resultados apresentados na tabela acima mostram que, calculando uma média aritmética, ou seja, deduzindo que o vocabulário de hardware pertencente a cada entidade é aproximadamente igual, o percentual de extração total atualmente é de 92\% dado um código genérico.

Devido a dificuldade para encontrar projetos \textit{opensource} realizamos testes com projetos obtidos em repositórios públicos no site \textit{https://github.com}, afim de aferir o Tempo de Extração (TE), em milissegundo (ms), e a Quantidade de Memória(QM) usada durante a extração. Os resultados obtidos estão expostos na tabela abaixo:
	
	\begin{table}[h]
\centering
\caption{Extração do \textit{Vocabulário de Hardware} de outros projetos.}
	\begin{tabular}{l|c|c}
	\hline
	Projeto  & TE(ms) & QM(B)\\
	\hline
	zynq-sandbox     & ... & ...\\
	\hline
	uvm-utest 	   & ... & ...\\
	\hline
	System-Verilog   & ... & ...\\
	\hline
	sha3\_sv\_tb       & ... & ...\\
	\hline
	sha3\_uvm\_tb     & ... & ...\\
	\hline
	apb2\_uvm\_tb   & ... & ...\\
	\hline
	spi\_uvm\_tb       & ... & ...\\
	\hline
	
	\end{tabular}

\end{table}	
	
	
Os resultados apresentados na tabela acima mostra que ...
	
	
	\section{Resultados e Discussões}
	
Ao 

% Representando o conjunto de todo o código fonte por S; e que cada elemento deste conjunto seja (alpha) temos que o vocabulario de hardware é definido como a imagem da função(HC) F(alpha) de tal forma que o conjunto imagem da função F seja o agrupamento dos dados na forma real da modelagem destes dados 

% sendo S o conjunto de todo o código fonte, e que cada elemento deste conjunto seja (alpha) temos que o vocabulario de hardware é definido como a imagem da função F (função Extração), onde im(F) é o agrupamento dos dados na forma real da modelagem destes dados. Assim F: S -> (HC)  

asdfsadfasdf

  
	\bibliography{refs}
	\bibliographystyle{abbrv}
	
\end{document}
