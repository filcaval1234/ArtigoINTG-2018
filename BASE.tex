\documentclass[12pt, twocolumn, a4paper]{article}
\usepackage{multicol, lipsum}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pslatex}
\usepackage[dvipsnames]{xcolor}
\usepackage{float}
\usepackage[a4paper, left=2cm, right=2cm, top=2cm, bottom=2cm,
		headsep=1cm, footskip=2cm]{geometry}
\usepackage[brazil]{babel}

\begin{document}
	\title{Hardware As Software}
	\author{Katyusco de F. Santos(1)\\
	\and
	Filipe C. Cavalanti(2)\\
	\and
	Leandro de S. Albuquerque(3)\\
	\texttt{Instituto Federal Da Paraíba}\\
	\texttt{Campus Campina Grande}\\
	\texttt{(1)katyusco.santos@ifpb.edu.br}\\
	\texttt{(2)filipe.cazuza@academico.ifpb.edu.br}\\
	\texttt{(3)leandro.albuquerque@academico.ifpb.edu.br}}
	\date{16 de abril de 2018}
	\maketitle
	
	\section{ABSTRACT}
	\quad Since the creation of the first HDLs (Hardware Description Language) to the present day, more and more the development of digital systems resembles the development of software systems. As the complexity in the development of digital systems has increased exponentially, the developing methodologies of such systems also evolves extensively.
	
The process of developing digital systems since the emergence of HDLs, uses concepts and paradigms of software engineering, in the beginning procedural programming and nowadays OOP (Object-Oriented Programming).

Software vocabulary consists of the set of repeated or unique terms that make up identifiers and which are present in the texts of the comments. Being the vocabulary or lexicon, one of the main sources of information in the scope of software engineering.

In this paper we defined the term \textit{Hardware Vocabulary}, in addition to extracting this vocabulary belonging to the SystemVerilog projects and demonstrating the similarity between HDLs and programming languages.
\begin{quote}
\textbf{keywords}: HDL; SystemVerilog; Software Vocabulary; Hardware Vocabulary; Digital Systems.
\end{quote}

	\section{RESUMO}
	\quad Desde a criação das primeiras HDLs(Hardware Description Language) até os presentes dias, cada vez mais o desenvolvimento de sistemas digitais se assemelha ao desenvolvimento de sistemas de software. Como a complexidade no desenvolvimento de sistemas digitais aumentou exponencialmente, as metodologias em desenvolvimento de tais sistemas também evolui extensivamente. %50 palavras

O processo de desenvolvimento de sistemas digitais desde o surgimento das HDLs, usa de conceitos e paradigmas da engenharia de software, indo da programação procedural até OOP(Object-Oriented Programming). %81 palavras

O vocabulário de software consiste no conjunto de termos repetidos ou únicos que compõem identificadores e que estão presentes no textos dos comentários. Sendo o vocabulário ou léxico, uma das principais fontes de informação no âmbito da engenharia de software. %122 palavras

Neste trabalho demonstramos a similaridade entre HDLs e linguagens de programação, definimos o termo \textit{Hardware Vocabulary} baseado na definição de \textit{Vocabulario de Software}, além de extrair o \textit{Vocabulário de Hardware} pertencente à projetos descritos em SystemVerilog. %156 palavras
\begin{quote}
\textbf{Palavras-chave}: HDL; SystemVerilog; Software Vocabulary; Hardware Vocabulary; Sistemas Digitais.
\end{quote}

% Keywords: HDL, SystemVerilog, Software Vocabulary, Hardware Vocabulary, sistemas digitais  
	\section{Introdução}

\quad Verilog foi uma das primeiras linguagens para descrição de hardware (HDL) a ser inventada em meados da década de 80. Até então o tamanho típico dos projetos era entre 5 a 10 mil portas lógicas. O método de concepção dos circuitos utilizava-se de esquema gráfico, e a simulação começava a ser  ferramenta essencial para verificação\cite{sutherland2006}. Com a evolução da tecnologia de descrição e verificação de hardware, em 2002 surge significante melhoria de Verilog que é SystemVerilog \cite{sutherland2006}. 

A partir disto, como a complexidade de sistemas digitais modernos aumentou exponencialmente, tanto que, o tamanho dos atuais projetos chega a ordem dos bilhões de portas lógicas. As metodologias de projetos em sistemas digitais estão evoluindo extensivamente \cite{Marc-Andre} e \cite{Hahanov2008}.

Com tal avanço, elevou-se o nível de abstração no desenvolvimento de hardware por meio de uma linguagem de descrição e verificação de hardware (HDVL), de tal forma que, o uso de ferramentas de análise de informações que antes eram somente do escopo da engenharia de software, pode ser estendido também para o desenvolvimento de sistemas digitais.

Umas das principais fontes de informações em um código fonte no âmbito da engenharia de software, é o vocabulário. Dentre suas principais utilidades listamos o seguinte:

\quad 1. Localização de bugs;

\quad 2. Identificação de uma arquitetura;

\quad 3. Métricas sobre o código fonte;

\quad 4. Identificação de especialista \cite{Santos2015}.

O vocabulário de software também denominado de léxico do código em \cite{Biggers2011}, consiste no conjunto de termos repetidos ou únicos que compõem identificadores e que estão presentes no textos dos comentários\cite{Abebe2009}.

Usando os princípios da engenharia reversa como uma coleção de metodologias e técnicas capazes de realizar a extração e abstração de informações\cite{Santos2009}, propõe-se neste trabalho apresentar a similaridade entre HDLs e linguagens de programação, usando a definição formal de Santos em \cite{Santos2015} sobre vocabulário de software para embasar e fundamentar o termo \textit{Hardware Vocabulary}, e extrair vocabulário pertencentes a projetos de hardware descritos em SystemVerilog. 

	\section{Background}
\quad Graças aos atuais projetos eletrônicos baseado em HDL, metodologias e ferramentas para simulação, síntese, verificação, modelagem física e teste pós-fabricação agora estão bem inseridos e são essenciais para designers digitais \cite{Navabi2015}. 

Nos últimos anos as linguagens de descrição e verificação de hardware tornaram-se tão importantes para a modelagem de sistemas digitais, quanto as linguagens de programação o são para a engenharia de software. 
	
	\subsection{Software Vocabulary}
\quad Santos em \cite{Santos2009}, define que vocabulário de software compreende as cadeias de caracteres que identificam os elementos estruturais e as palavras que compõem as sentenças dos comentários de um código fonte. 

Dentro dos campos de estudo da engenharia de software outro termo bastante conhecido e isomorfo a \textit{Software Vocabulary} é o \textit{léxico do código} que em \cite{Biggers2011} são os elementos que nomeiam as entidades estruturais da linguagem além dos comentários escritos em linguagem natural.

 \textit{Software Vocabulary} é um multiconjunto de \textit{Strings}, i.e., uma aplicação $V:$ $\mathbb{S}\rightarrow\mathbb{N}$, que mapeia \textit{Strings} para números naturais. Elementos de um vocabulário são chamados \textit{termos}. Para qualquer termo $t$, $V(t)$ representa o número de ocorrências do termo $t$ no vocabulário $V$. Se $V(t)>0$ dizemos que $t$ é um termo do vocabulário \cite{Santos2015}.

% O lexico de um programa representa um investimento substancial para uma empresa de software, portanto, seu valor deve preservado e aumentado ao longo do tempo, para aproveitar ao máximo seus efeitos benéficos na compreensão do programa.(Antoniol)

No paradigma de programação dominante atualmente OOP(\textit{Object-Oriented Programming}), nomear os elementos estruturais da linguagem de forma concisa e representativa além de documentá-las, tem sido mais do que uma boa prática.

 No desenvolvimento de grandes sistemas de software o vocabulário ou léxico, quando condizente ao problema, reduz o tempo de manutenção, facilita o entendimento do código e encontro de \textit{bugs}.

O léxico de um programa representa um investimento substancial para uma empresa de software, portanto, sua importância deve preservada e elevada ao longo do tempo, para aproveitar ao máximo seus efeitos e benéficos na compreensão do programa \cite{Antoniol2007}.

	\subsection{Hardware Description Language (HDL)}

\quad Uma HDL(\textit{Hardware Description Language}) descreve o funcionamento do circuito, a sua concepção e organização e ainda o testa para verificar seu funcionamento por meio de simulação\cite{Miller-Karlow}.

As HDLs modernas são fundamentais para o desenvolvimento de sistemas digitais, possibilitando suas descrições de forma estrutural, comportamental e nos últimos anos, seguindo conceitos básicos de orientação a objetos \cite{Hahanov2008}, fornecendo assim um mecanismo efetivo para o desenvolvimento de projetos à medida que evoluem da abstração para a realidade \cite{Navabi2015}.

Algumas HDls evoluíram de tal forma que, além de descrever hardware, passaram também a englobar todo um ambiente de verificação. Tais linguagens foram tipificadas de HDVL (Hardware Description and Verification Language).

Limitamos o escopo deste trabalho à análise de informações somente para projetos descritos em SystemVerilog. A escolha dessa linguagem deve-se ao seu grande uso na industria VLSI (\textit{Very Large Scale Integration} \cite{Kumar2014} e também por SystemVerilog ser uma HDVL \cite{IEEEComputerSociety2013}, ampliando assim nosso horizonte de informações, uma vez que temos dados tanto sobre descrição quanto verificação de hardware.

%--------------apagar essa parada!!!! DATTEBAYO
%A sintaxe pesada de uma HDL apresenta um problema no desenvolvimento de projetos, pois descreve um sistema complexo e multifacetado por meio de uma representação textual unidimencional, dificultando a abstração de \textit{\textbf{muitos}} aspetos do projeto.

	\subsection{O Hardware Como Um Software}
\quad A evolução no processo de desenvolvimento de software atrela-se ao fato do constante avanço dos paradigmas de programação, desde a programação procedural até a orientação a objetos.

De forma análoga, a evolução do processo de desenvolvimento de hardware, atrela-se também ao constante avanço dos métodos em desenvolver sistemas digitais. Indo desde esquemas gráficos à descrição baseada em orientação a objetos e verificação UVM (\textit{Universal Verification Methodology}).

A aproximação (similaridade no processo de desenvolvimento) do software ao hardware surge da criação das HDLs. Neste ponto da evolução tecnológica, tanto hardware quanto software eram desenvolvidos por meio de uma representação textual unidemensional, seguindo uma determinada sintaxe e semântica.

Em \cite{Hahanov2008} classes e módulos são coisas bastantes semelhantes, trazendo assim a possibilidade de usar classes dentro de um contexto de verificação de hardware. A partir desta similaridade, o inverso também é possível, ou seja, utilizar de conceitos e convenções de orientação a objetos na descrição de módulos.

	\subsection{Hardware Vocabulary} 
	
\quad Baseado fortemente pela definição formal de vocabulário de software em  \cite{Santos2015}, e embasado também por todo o levantamento feito sobre as semelhanças entre os processos de desenvolvimento entre hardware e software feitas na sessão anterior. Chegamos a primeira definição sobre vocabulário de hardware:
	
(1) Dada uma linguagem de descrição e (ou) verificação de hardware, temos que as sequencias de caracteres que nomeiam as entidades estruturais, assim como os blocos de comentários são chamados de \textit{Vocabulário de Hardware}.

Complementando tal definição, o vocabulário de hardware refere-se também a como estes dados estão organizados, ou seja, a estruturação da informação refletindo as entidades a qual o léxico pertence, de modo que só com o vocabulário possa ser possível criar uma entidade complementar a original (entidade que seu vocabulário foi extraído).

Notando tal semelhança a definição de vocabulário de software e sabendo de seu isomorfismo com léxico do código(definição dada por Biggers em \cite{Biggers2011}), chegamos a conclusão que (1) também pode ser chamado de \textit{léxico do hardware}.

Uma exemplificação é dada a partir de um trecho de código mostrado na \textit{Listing 1}, onde seu vocabulário extraído, está numa representação VXL(Vocabulary XML).
\begin{center}
{\footnotesize Listing 1: Execerpt of code SystemVerilog}
\end{center}
{\footnotesize
\textcolor{gray}{/* the module nextAddress returns the}
\textcolor{gray}{next address of the 2-bit offset program}
\textcolor{gray}{*/}\\
\textcolor{blue}{module} nextAddress(\\\textcolor{blue}{\qquad input logic}[\textcolor{green}{7}:\textcolor{green}{0}] regCounter,\\ \textcolor{blue}{\qquad input logic}[\textcolor{green}{7}:\textcolor{green}{0}] regAddress,\\
\textcolor{blue}{\qquad output logic}[\textcolor{green}{7}:\textcolor{green}{0}] regPC);\\
\textcolor{blue}{\quad always\_comb begin}\\
\textcolor{black}{\qquad regPC = (regCounter + regAddress)} \textcolor{blue}{$<<$} \textcolor{green}{2};\\
\textcolor{blue}{\quad end}\\
\textcolor{blue}{endmodule}: nextAddress\\
\begin{center}
{\footnotesize Listing 2: Extracted Vocabulary of Listing 1}
\end{center}}
{\footnotesize
\textcolor{blue}{$<$mdl} \textcolor{red}{\,name=} ``\textcolor{purple}{nextAddress}"\textcolor{blue}{$>$}\\
\textcolor{blue}{\quad$<$prm$>$}\\
\textcolor{blue}{\qquad$<$fld} \textcolor{red}{type=}``\textcolor{purple}{input logic[7:0]}"\textcolor{red}{\,name=}\\\textcolor{black}{\qquad ``}\textcolor{purple}{regCounter}" \textcolor{blue}{/$>$}\\
\textcolor{blue}{\qquad$<$fld} \textcolor{red}{type=}``\textcolor{purple}{input logic[7:0]}"\textcolor{red}{\,name=}\\\textcolor{black}{\qquad ``}\textcolor{purple}{regAddress}" \textcolor{blue}{/$>$}\\
\textcolor{blue}{\qquad$<$fld} \textcolor{red}{type=}``\textcolor{purple}{output logic[7:0]}"\textcolor{red}{\,name=} ``\textcolor{purple}{regPC}" \textcolor{blue}{/$>$}\\
\textcolor{blue}{\quad$<$/prm$>$}\\
\textcolor{blue}{\quad$<$cmt} \textcolor{red}{cmm=}``\textcolor{purple}{the module nextAddress returns the next address of the 2-bit offset program}"\textcolor{blue}{/$>$}\\
\textcolor{blue}{$<$/mdl$>$}}\\

Como pode ser notado no resultado da extração do vocabulário, a estruturação dos dados segue fielmente a modelagem original do problema, assim sendo a partir do vocabulário pode-se recriar uma entidade complementar a original.

Notamos que a definição formal de Santos em \cite{Santos2015} sobre vocabulário de software, aplica-se igualmente ao vocabulário de hardware, assim chegamos a definição formal de vocabulário de hardware:

(2) \textit{Hardware Vocabulary definition}: Definimos \textit{Hardware Vocabulary} como um multiconjunto de \textit{Strings}, isto é, uma aplicação $V:$ $\mathbb{S}\rightarrow\mathbb{N}$, que mapeia \textit{Strings} para números naturais. Elementos de um vocabulário são chamados \textit{termos}. Para qualquer termo $t$, $V(t)$ representa o número de ocorrências do termo $t$ no vocabulário $V$. Se $V(t)>0$ dizemos que $t$ é um termo do vocabulário.

Como um exemplo considere o trecho de código em \textit{Listing 1}. De acordo com nossa definição o \textit{Vocabulário de Hardware} pode ser expresso como o seguinte multconjunto de termos:\\

$V= 2'regCounter + 2'regAddress + 2'regPC + 2'nextAddress$


	\section{SystemVerilog Vocabulary Extractor}

\quad Com a necessidade de analisar e extrair o vocabulário de hardware pertencentes a projetos descritos em SystemVerlog, desenvolvemos o ferramental \textit{Hardware Vocabulary Tool}.

A implementação desta ferramenta, baseia-se em entidades que são capazes de processar o vocabulário de hardware dos principais elementos estruturais básicos de SystemVerilog. Usando de delegação montam-se as estruturas mais complexas da linguagem (classes, interfaces, módulos e pacotes) Ex.: Uma classe SystemVerilog é uma entidade que possui um nome e compõem-se principalmente de atributos, funções, tasks, comentários.

Para posterior análise, o resultado da extração é salvo em arquivo .xml seguindo a estruturação da \textit{Listing 2}, contendo a extração de todas as entidades estruturais da linguagem.
	
Afim de validarmos a ferramenta calculamos uma porcentagem de extracão que melhor represente a eficiência do software proposto, elaborando um design genérico com todas as estruturas possíveis da linguagem SistemVerilog. Os resultados obtidos são apresentados na tabela abaixo:

\begin{table}[h]
\centering
\caption{Porcentagem de extração das principais entidades de SystemVerilog.}
	\begin{tabular}{l|c}
	\hline
	Entidade  & Porcentagem de extração\\
	\hline
	module     & 90\% \\
	\hline
	class 	   & 98\% \\
	\hline
	interface  & 90\% \\
	\hline
	function   & 100\% \\
	\hline
	task       & 90\% \\
	\hline
	fields     & 100\% \\
	\hline
	
	\end{tabular}

\end{table}
Os resultados apresentados na tabela acima mostram que, calculando uma média aritmética, ou seja, deduzindo que o vocabulário de hardware pertencente a cada entidade é aproximadamente igual, o percentual de extração total atualmente é de 94\% dado um código genérico.

Fizemos uma busca por projetos de hardware \textit{opensource} em repositórios públicos no site \textit{https://github.com}, afim de aferir o Tempo de Execução da Extração (TE) em milissegundo (ms), Quantidade de Linhas (QL) e o Tamanho do Projeto(TP) medido em Bytes. Os resultados obtidos estão expostos na tabela 2.
	
\begin{table*}[h]
\centering
\caption{Extração do \textit{Vocabulário de Hardware} de projetos \textit{opensource}.}
	\begin{tabular}{l|c|c|c}
	\hline
	Nome do Projeto & TP(Bytes)& QL & TE (ms)\\
	\hline
	ahb\_apb\_bridge\_uvm\_tb&&&\\{\footnotesize https://github.com/mayur13/UVM/tree/master/projects/ahb\_apb\_bridge\_uvm\_tb}& 122.880 & 997 & 260\\

	\hline
	apb2\_uvm\_tb&&&\\{\footnotesize https://github.com/mayur13/UVM/tree/master/projects/apb2\_uvm\_tb}     & 147.456 & 806 & 278\\
	\hline
	fpga\_fast\_serial\_sort&&&\\{\footnotesize https://github.com/Poofjunior/fpga\_fast\_serial\_sort} 	   & 49.152 & 351 & 205\\
	\hline
	System-Verilog&&&\\{\footnotesize https://github.com/zricethezav/System-Verilog}   & 49.221.632 & 4420 & 970\\
	\hline
	sha3\_sv\_tb&&&\\{\footnotesize https://github.com/mayur13/SystemVerilog/tree/master/projects/sha3\_sv\_tb}       & 65.536 & 242 & 297 \\
	\hline
	sha3\_uvm\_tb&&&\\{\footnotesize https://github.com/mayur13/UVM/tree/master/projects/sha3\_uvm\_tb}& 176.128 & 925 & 278\\
	\hline
	uvm-tutorial-for-candy-lovers&&&\\{\footnotesize https://github.com/cluelogic/uvm-tutorial-for-candy-lovers}  & 700.416 & 11.559 & 1.877\\
	\hline
	spi\_uvm\_tb&&&\\{\footnotesize https://github.com/mayur13/UVM/tree/master/projects/spi\_uvm\_tb}      & 139.264 & 172 & 177\\
	\hline
	uvm-utest&&&\\{\footnotesize https://github.com/nosnhojn/uvm-utest}& 311.296 & 5281 & 1.379\\
	\hline
	zynq-sandbox&&&\\{\footnotesize https://github.com/swetland/zynq-sandbox}& 450.560 & 8671 & 546\\
	\hline
	\end{tabular}

\end{table*}		
	
	\section{Resultados e Discussões}
  
\quad Cada Desenvolvedor tem seu vocabulário, que é a acumulação de termos manipulados (adicionados, removidos e substituídos) durante suas contribuições no projeto \cite{Santos2015}. Isso equivale à desenvolvimento de hardware, uma vez citada a similaridade entre as HDLs e as linguagens de programação.

Com a definição de \textit{Vocabulário de Hardware} formalizada, abrimos então um novo campo de estudos para a engenharia de software. A análise e extração de informação pertencentes ao vocabulário de projetos de hardware descritos por alguma HDL.

Levantada todas as semelhanças do processo de desenvolvimento de hardware ao software, concluímos que toda analise, extração, métricas e conclusões feitas com base no vocabulário de software são equivalentes quando aplicadas ao Vocabulário de Hardware.

Então com o \textit{Vocabulário de Hardware} é possível encontrar  \textit{bugs}, identificar uma arquitetura, fazer métricas sobre o código e identificar especialista. Com todo o arcabouço de informações e teorias que a engenharia de software desenvolveu ao longo dos anos baseando-se em léxico e vocabulário de software.

	\bibliography{refs}
	\bibliographystyle{abbrv}
	
\end{document}
