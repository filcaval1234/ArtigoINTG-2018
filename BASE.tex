\documentclass[12pt, twocolumn, a4paper]{article}
\usepackage{multicol, lipsum}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pslatex}
\usepackage[a4paper, left=3cm, right=2cm, top=3cm, bottom=2cm,
		headsep=1cm, footskip=2cm]{geometry}
\usepackage[brazil]{babel}

\begin{document}
	\title{SystemVerilog Vocabulary Extractor}
	\author{Filipe C. Cavalcanti\\ Leandro de S. Albuquerque\\
	Orientador: Tio Kat}
	\maketitle
	
	\section{ABSTRACT}
	
	\section{RESUMO}
	\quad Desde a criação da primeira HDL até os presentes dias, cada vez mais o desenvolvimento de sistemas digitais se assemelha e aproxima-se a codificações de programas descritos em linguagem de programação  
	
% Keywords: HDL, SystemVerilog, Software Vocabulary, Hardware Vocabulary, sistemas digitais  
	\section{Introdução}

\quad Verilog foi uma das primeiras linguagens para descrição de hardware (HDL) a ser inventada, em meados da década de 80. O tamanho típico dos projetos era entre de 5 a 10 mil portas lógicas. O método de concepção dos circuitos utilizava-se de esquema gráfico, e a simulação começava a ser uma ferramenta essencial para verificação\cite{sutherland2006}. Com a evolução da tecnologia de descrição e verificação de hardware, em 2002 surge SystemVerilog. 

A partir disto, como a complexidade de sistemas digitais modernos aumentou exponencialmente, tanto que, o tamanho dos atuais projetos chega a ordem dos bilhões de portas lógicas. Assim as metodologias de projetos em sistemas digitais estão evoluindo extensivamente \cite{Marc-Andre} e \cite{Hahanov2008}.

Com tal avanço, elevou-se o nível de abstração no desenvolvimento de hardware por meio de uma linguagem de descrição e verificação de hardware (HDVL), de tal forma que, o uso de ferramentas de análise de informações que antes eram somente do escopo da engenharia de software, pode ser estendido também para o desenvolvimento de sistemas digitais.

Umas das principais fontes de informações em um código fonte no âmbito da engenharia de software, é o vocabulário. Dentre suas principais utilidades listamos o seguinte:\\
\quad 1. Localização de bugs;\\
\qquad 2. Identificação de uma arquitetura;\\
\qquad 3. Métricas sobre o código fonte;\\
\qquad 4. Identificação de especialista \cite{Santos2015}.

O vocabulário de software também denominado de léxico do código em \cite{Biggers2011}, consiste no conjunto de termos repetidos ou únicos que compõem identificadores e que estão presentes no textos dos comentários\cite{Abebe2009}.

Usando os princípios da engenharia reversa como uma coleção de metodologias e técnicas capazes de realizar a extração e abstração de informações\cite{Santos2009}, propõe-se neste trabalho a extração do vocabulário pertencentes a projetos de hardware descritos em SystemVerilog, e usando a definição formal de Santos em \cite{Santos2015} sobre vocabulário de software para embasar e fundamentar o termo \textit{Hardware Vocabulary}. 

	\section{Background}
\quad Graças aos atuais projetos eletrônicos baseado em HDL, metodologias e ferramentas para simulação, síntese, verificação, modelagem física e teste pós-fabricação agora estão bem inseridos e são essenciais para designers digitais \cite{Navabi2015}. Nos últimos anos as linguagens de descrição e verificação de hardware tornaram-se tão importantes para a modelagem de sistemas digitais, quanto as linguagens de programação o são para a engenharia de software. 
	
	\subsection{Software Vocabulary}
\quad Santos em \cite{Santos2009}, define que vocabulário de código fonte compreende as cadeias de caracteres que identificam os elementos estruturais e as palavras que compõem as sentenças dos comentários de um código fonte. Dentro dos campos de estudo da engenharia de software outro termo bastante conhecido e isomorfo a \textit{Software Vocabulary} é o \textit{léxico do código} que em \cite{Biggers2011} são os elementos que nomeiam as entidades estruturais da linguagem além dos comentários escritos em linguagem natural.

 \textit{Software Vocabulary} é um multiconjunto de \textit{Strings}, i.e. uma aplicação $V:$ $\mathbb{S}\rightarrow\mathbb{N}$, que mapeia \textit{Strings} para números naturais. Elementos de um vocabulário são chamados \textit{termos}. Para qualquer termo $t$, $V(t)$ representa o número de ocorrências do termo $t$ no vocabulário $V$. Se $V(t)>0$ dizemos que $t$ é um termo do vocabulário \cite{Santos2015}.

% O lexico de um programa representa um investimento substancial para uma empresa de software, portanto, seu valor deve preservado e aumentado ao longo do tempo, para aproveitar ao máximo seus efeitos benéficos na compreensão do programa.(Antoniol)

No paradigma de programação dominante atualmente OOP (\textit{Object-Oriented Programming}), nomear os elementos estruturais da linguagem de forma concisa e representativa além de documenta-las, tem sido mais do que uma boa prática .

 No desenvolvimento de grandes sistemas o léxico ou SV (\textit{Software Vocabulary}), quando condizente ao problema, reduz o tempo de manutenção, facilita o entendimento do código e encontro de \textit{bugs}. 

O léxico de um programa representa um investimento substancial para uma empresa de software, portanto, sua importância deve preservada e elevada ao longo do tempo, para aproveitar ao máximo seus efeitos e benéficos na compreensão do programa \cite{Antoniol2007}.

	\subsection{O Que é Uma HDL?}
%\quad HDVL (Hardware Description and Verification Language), podemos abstrair como um único ambiente para design e verificação de sistemas digitais, em \cite{Flake} uma HDVL representa hardware digital em vários níveis de abstração.

\quad Uma descrição HDL(\textit{Hardware Description Language}) é uma representação precisa que pode ser usada para documentar, comunicar e simular o projeto \cite{Miller-Karlow}.

As HDLs modernas são fundamentais para o desenvolvimento de sistemas digitais, possibilitando suas descrições de forma estrutural, comportamental e nos últimos anos, seguindo conceitos básicos de orientação a objetos, fornecendo assim um mecanismo efetivo para o desenvolvimento de projetos à medida que evoluem da abstração para a realidade.

%--------------apagar essa parada!!!! DATTEBAYO
%A sintaxe pesada de uma HDL apresenta um problema no desenvolvimento de projetos, pois descreve um sistema complexo e multifacetado por meio de uma representação textual unidimencional, dificultando a abstração de \textit{\textbf{muitos}} aspetos do projeto.

	\subsection{O Hardware Como Um Software}
\quad A evolução no processo de desenvolvimento de software atrela-se ao fato do constante avanço dos paradigmas de programação, desde a programação procedural até a orientação a objetos. De forma análoga, a evolução do processo de desenvolvimento de hardware, atrela-se também ao constante avanço dos métodos em desenvolver sistemas digitais. Indo desde esquemas gráficos à descrição baseada em orientação a objetos e verificação UVM (\textit{Universal Verification Methodology}).

A aproximação (similaridade no processo de desenvolvimento) do software ao Hardware surge da criação das HDLs. Neste ponto da evolução tecnológica, tanto hardware quanto software eram desenvolvidos por meio de uma representação textual unidemensional, seguindo uma determinada sintaxe e semântica. Em \cite{Hahanov2008} classes e módulos são coisas bastantes semelhantes, trazendo assim a possibilidade de usar classes dentro de um contexto de verificação de hardware. 

	\subsection{Hardware Vocabulary} 
	
Dada uma linguagem de descrição e (ou) verificação de hardware temos que;\\
As sequencias de caracteres que nomeiam as entidades estruturais assim como os blocos de comentários são chamados de \textit{Vocabulário de Hardware}, de forma que .  

Sendo $S$ o conjunto de todo o código fonte, e que cada elemento deste conjunto seja $\alpha$ , temos que o vocabulário de hardware é definido como  a imagem da função $F(\alpha)$ (função Extração), onde $im(F) = \mathbb{HV}$ é o agrupamento dos dados na forma real da modelagem destes dados. Assim $F: \mathbb{S}\rightarrow\mathbb{HV}$
	\section{SystemVerilog Vocabulary Extractor}
	
\quad A fim de analisar e extrair o vocabulario de hardware pertencentes a projetos descritos em SystemVerlog desenvolvemos o ferramental \textit{Hardware Vocabulary Tool}, e \cite{AVLSystemVerilog}
	
	
	\quad Afim de calcularmos uma porcentagem de extracão que melhor represente a eficiência do software proposto, foi elaborado um design genérico com todas as estruturas possíveis em SistemVerilog. Os resultados obtidos são apresentados na tabela abaixo:

\begin{table}[h]
\centering
\caption{Hello Word Table}
	\begin{tabular}{r|l|r}
	\hline
	posição & País & IDH\\
	\hline
	1 & Noruega        & .955 \\
	\hline
	2 & Austrália 	   & .938 \\
	\hline
	3 & EUA            &. 937 \\
	\hline
	4 & Holanda        & .921 \\
	\hline
	5 & Alemanha       & .920 \\
	\hline
	
	\end{tabular}

\end{table}

\quad Os resultados apresentados na tabela acima mostra que ...

	Foram realizados, também, outros testes com hardware \textit{opensource} obtidos em repositórios no Github. Os resultados obtidos estão expostos na tabela abaixo:
	\section{Resultados e Discussões}
	
	\begin{table}[h]
\centering
\caption{Hello Word Table}
	\begin{tabular}{r|l|r}
	\hline
	posição & País & IDH\\
	\hline
	1 & Noruega        & .955 \\
	\hline
	2 & Austrália 	   & .938 \\
	\hline
	3 & EUA            &. 937 \\
	\hline
	4 & Holanda        & .921 \\
	\hline
	5 & Alemanha       & .920 \\
	\hline
	
	\end{tabular}

\end{table}


% Representando o conjunto de todo o código fonte por S; e que cada elemento deste conjunto seja (alpha) temos que o vocabulario de hardware é definido como a imagem da função(HC) F(alpha) de tal forma que o conjunto imagem da função F seja o agrupamento dos dados na forma real da modelagem destes dados 

% sendo S o conjunto de todo o código fonte, e que cada elemento deste conjunto seja (alpha) temos que o vocabulario de hardware é definido como a imagem da função F (função Extração), onde im(F) é o agrupamento dos dados na forma real da modelagem destes dados. Assim F: S -> (HC)  
	
  
	\bibliography{refs}
	\bibliographystyle{abbrv}
	
\end{document}
